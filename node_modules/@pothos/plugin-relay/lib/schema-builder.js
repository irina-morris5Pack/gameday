"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    connectionRefs: ()=>connectionRefs,
    globalConnectionFieldsMap: ()=>globalConnectionFieldsMap
});
const _graphql = require("graphql");
const _core = /*#__PURE__*/ _interopRequireWildcard(require("@pothos/core"));
const _utils = require("./utils");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const schemaBuilderProto = _core.default.prototype;
const pageInfoRefMap = new WeakMap();
const nodeInterfaceRefMap = new WeakMap();
const connectionRefs = new WeakMap();
const globalConnectionFieldsMap = new WeakMap();
schemaBuilderProto.pageInfoRef = function pageInfoRef() {
    if (pageInfoRefMap.has(this)) {
        return pageInfoRefMap.get(this);
    }
    const ref = this.objectRef('PageInfo');
    pageInfoRefMap.set(this, ref);
    const { cursorType ='String' , hasNextPageFieldOptions ={} , hasPreviousPageFieldOptions ={} , startCursorFieldOptions ={} , endCursorFieldOptions ={}  } = this.options.relayOptions;
    ref.implement({
        ...this.options.relayOptions.pageInfoTypeOptions,
        fields: (t)=>({
                hasNextPage: t.exposeBoolean('hasNextPage', {
                    nullable: false,
                    ...hasNextPageFieldOptions
                }),
                hasPreviousPage: t.exposeBoolean('hasPreviousPage', {
                    nullable: false,
                    ...hasPreviousPageFieldOptions
                }),
                startCursor: t.expose('startCursor', {
                    nullable: true,
                    ...startCursorFieldOptions,
                    type: cursorType
                }),
                endCursor: t.expose('endCursor', {
                    nullable: true,
                    ...endCursorFieldOptions,
                    type: cursorType
                })
            })
    });
    return ref;
};
schemaBuilderProto.nodeInterfaceRef = function nodeInterfaceRef() {
    var _this_options_relayOptions, _this_options_relayOptions_nodeQueryOptions, _this_options_relayOptions1, _this_options_relayOptions_nodesQueryOptions;
    if (nodeInterfaceRefMap.has(this)) {
        return nodeInterfaceRefMap.get(this);
    }
    const ref = this.interfaceRef('Node');
    nodeInterfaceRefMap.set(this, ref);
    var _this_options_relayOptions_idFieldName;
    ref.implement({
        resolveType: (value, context, info, graphQLType)=>{
            if (!value) {
                return (0, _graphql.defaultTypeResolver)(value, context, info, graphQLType);
            }
            const typeBrand = (0, _core.getTypeBrand)(value);
            if (typeBrand) {
                const type = this.configStore.getTypeConfig(typeBrand);
                return type.name;
            }
            try {
                if (typeof value === 'object') {
                    // eslint-disable-next-line no-underscore-dangle
                    const typename = value.__typename;
                    if (typename) {
                        return typename;
                    }
                    // eslint-disable-next-line no-underscore-dangle
                    const nodeRef = value.__type;
                    if (nodeRef) {
                        const config = this.configStore.getTypeConfig(nodeRef);
                        if (config) {
                            return config.name;
                        }
                    }
                }
            } catch  {
            // ignore
            }
            return (0, _graphql.defaultTypeResolver)(value, context, info, graphQLType);
        },
        ...this.options.relayOptions.nodeTypeOptions,
        fields: (t)=>{
            var _this_options_relayOptions;
            return {
                [(_this_options_relayOptions_idFieldName = (_this_options_relayOptions = this.options.relayOptions) === null || _this_options_relayOptions === void 0 ? void 0 : _this_options_relayOptions.idFieldName) !== null && _this_options_relayOptions_idFieldName !== void 0 ? _this_options_relayOptions_idFieldName : 'id']: t.globalID({
                    nullable: false,
                    resolve: (parent)=>{
                        throw new Error('id field not implemented');
                    }
                })
            };
        }
    });
    const resolveNodeFn = (_this_options_relayOptions = this.options.relayOptions) === null || _this_options_relayOptions === void 0 ? void 0 : (_this_options_relayOptions_nodeQueryOptions = _this_options_relayOptions.nodeQueryOptions) === null || _this_options_relayOptions_nodeQueryOptions === void 0 ? void 0 : _this_options_relayOptions_nodeQueryOptions.resolve;
    this.queryField('node', (t)=>t.field({
            nullable: true,
            ...this.options.relayOptions.nodeQueryOptions,
            type: ref,
            args: {
                id: t.arg.globalID({
                    required: true
                })
            },
            resolve: resolveNodeFn ? (root, args, context, info)=>resolveNodeFn(root, args, context, info, async (ids)=>(await (0, _utils.resolveNodes)(this, context, info, [
                        args.id
                    ]))[0]) : async (root, args, context, info)=>(await (0, _utils.resolveNodes)(this, context, info, [
                    args.id
                ]))[0]
        }));
    const resolveNodesFn = (_this_options_relayOptions1 = this.options.relayOptions) === null || _this_options_relayOptions1 === void 0 ? void 0 : (_this_options_relayOptions_nodesQueryOptions = _this_options_relayOptions1.nodesQueryOptions) === null || _this_options_relayOptions_nodesQueryOptions === void 0 ? void 0 : _this_options_relayOptions_nodesQueryOptions.resolve;
    this.queryField('nodes', (t)=>t.field({
            nullable: {
                list: false,
                items: true
            },
            ...this.options.relayOptions.nodesQueryOptions,
            type: [
                ref
            ],
            args: {
                ids: t.arg.globalIDList({
                    required: true
                })
            },
            resolve: resolveNodesFn ? (root, args, context, info)=>resolveNodesFn(root, args, context, info, (ids)=>(0, _utils.resolveNodes)(this, context, info, args.ids)) : (root, args, context, info)=>(0, _utils.resolveNodes)(this, context, info, args.ids)
        }));
    return ref;
};
schemaBuilderProto.node = function node(param, { interfaces , ...options }, fields) {
    (0, _core.verifyRef)(param);
    const interfacesWithNode = ()=>[
            this.nodeInterfaceRef(),
            ...typeof interfaces === 'function' ? interfaces() : interfaces !== null && interfaces !== void 0 ? interfaces : []
        ];
    let nodeName;
    var _options_isTypeOf;
    const ref = this.objectType(param, {
        ...options,
        isTypeOf: (_options_isTypeOf = options.isTypeOf) !== null && _options_isTypeOf !== void 0 ? _options_isTypeOf : typeof param === 'function' ? (maybeNode, context, info)=>{
            if (!maybeNode) {
                return false;
            }
            if (maybeNode instanceof param) {
                return true;
            }
            const proto = Object.getPrototypeOf(maybeNode);
            try {
                if (proto === null || proto === void 0 ? void 0 : proto.constructor) {
                    const config = this.configStore.getTypeConfig(proto.constructor);
                    return config.name === nodeName;
                }
            } catch  {
            // ignore
            }
            return false;
        } : undefined,
        interfaces: interfacesWithNode
    }, fields);
    this.configStore.onTypeConfig(ref, (nodeConfig)=>{
        nodeName = nodeConfig.name;
        var _this_options_relayOptions_idFieldName;
        this.objectField(ref, (_this_options_relayOptions_idFieldName = this.options.relayOptions.idFieldName) !== null && _this_options_relayOptions_idFieldName !== void 0 ? _this_options_relayOptions_idFieldName : 'id', (t)=>t.globalID({
                nullable: false,
                ...this.options.relayOptions.idFieldOptions,
                ...options.id,
                args: {},
                resolve: async (parent, args, context, info)=>({
                        type: nodeConfig.name,
                        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                        id: await options.id.resolve(parent, args, context, info)
                    })
            }));
    });
    return ref;
};
schemaBuilderProto.globalConnectionField = function globalConnectionField(name, field) {
    var _connectionRefs_get;
    const onRef = (ref)=>{
        this.objectField(ref, name, field);
    };
    (_connectionRefs_get = connectionRefs.get(this)) === null || _connectionRefs_get === void 0 ? void 0 : _connectionRefs_get.forEach((ref)=>void onRef(ref));
    if (!globalConnectionFieldsMap.has(this)) {
        globalConnectionFieldsMap.set(this, []);
    }
    globalConnectionFieldsMap.get(this).push(onRef);
};
schemaBuilderProto.globalConnectionFields = function globalConnectionFields(fields) {
    var _connectionRefs_get;
    const onRef = (ref)=>{
        this.objectFields(ref, fields);
    };
    (_connectionRefs_get = connectionRefs.get(this)) === null || _connectionRefs_get === void 0 ? void 0 : _connectionRefs_get.forEach((ref)=>void onRef(ref));
    if (!globalConnectionFieldsMap.has(this)) {
        globalConnectionFieldsMap.set(this, []);
    }
    globalConnectionFieldsMap.get(this).push(onRef);
};
const mutationIdCache = (0, _core.createContextCache)(()=>new Map());
schemaBuilderProto.relayMutationField = function relayMutationField(fieldName, inputOptionsOrRef, { resolve , ...fieldOptions }, { name: payloadName = `${(0, _utils.capitalize)(fieldName)}Payload` , outputFields , interfaces , ...paylaodOptions }) {
    var _this_options_relayOptions;
    const { relayOptions: { clientMutationIdInputOptions ={} , clientMutationIdFieldOptions ={} , mutationInputArgOptions ={}  }  } = this.options;
    const includeClientMutationId = this.options.relayOptions.clientMutationId !== 'omit';
    let inputRef;
    let argName = 'input';
    if (inputOptionsOrRef instanceof _core.InputObjectRef) {
        inputRef = inputOptionsOrRef;
    } else {
        var _this_options_relayOptions1;
        const { name: inputName = `${(0, _utils.capitalize)(fieldName)}Input` , argName: argNameFromOptions = 'input' , inputFields , ...inputOptions } = inputOptionsOrRef;
        argName = argNameFromOptions;
        inputRef = this.inputType(inputName, {
            ...(_this_options_relayOptions1 = this.options.relayOptions) === null || _this_options_relayOptions1 === void 0 ? void 0 : _this_options_relayOptions1.defaultMutationInputTypeOptions,
            ...inputOptions,
            fields: (t)=>({
                    ...inputFields(t),
                    ...includeClientMutationId ? {
                        clientMutationId: t.id({
                            ...clientMutationIdInputOptions,
                            required: this.options.relayOptions.clientMutationId !== 'optional'
                        })
                    } : {}
                })
        });
    }
    const payloadRef = this.objectRef(payloadName).implement({
        ...(_this_options_relayOptions = this.options.relayOptions) === null || _this_options_relayOptions === void 0 ? void 0 : _this_options_relayOptions.defaultPayloadTypeOptions,
        ...paylaodOptions,
        interfaces: interfaces,
        fields: (t)=>({
                ...outputFields(t),
                ...includeClientMutationId ? {
                    clientMutationId: t.id({
                        nullable: this.options.relayOptions.clientMutationId === 'optional',
                        ...clientMutationIdFieldOptions,
                        resolve: (parent, args, context, info)=>mutationIdCache(context).get(String(info.path.prev.key))
                    })
                } : {}
            })
    });
    this.mutationField(fieldName, (t)=>t.field({
            ...fieldOptions,
            type: payloadRef,
            args: {
                [argName]: t.arg({
                    ...mutationInputArgOptions,
                    type: inputRef,
                    required: true
                })
            },
            resolve: (root, args, context, info)=>{
                mutationIdCache(context).set(String(info.path.key), args[argName].clientMutationId);
                return resolve(root, args, context, info);
            }
        }));
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    return {
        inputType: inputRef,
        payloadType: payloadRef
    };
};
schemaBuilderProto.connectionObject = function connectionObject({ type , name: connectionName , edgesNullable: edgesNullableField , nodeNullable , ...connectionOptions }, edgeOptionsOrRef) {
    var _this_options_relayOptions, _globalConnectionFieldsMap_get;
    (0, _core.verifyRef)(type);
    const { edgesFieldOptions: { nullable: edgesNullable = {
        items: true,
        list: false
    } , ...edgesFieldOptions } = {} , pageInfoFieldOptions ={}  } = this.options.relayOptions;
    const connectionRef = this.objectRef(connectionName);
    const edgeRef = edgeOptionsOrRef instanceof _core.ObjectRef ? edgeOptionsOrRef : this.edgeObject({
        name: `${connectionName.replace(/Connection$/, '')}Edge`,
        ...edgeOptionsOrRef,
        nodeNullable,
        type
    });
    const connectionFields = connectionOptions.fields;
    const { nodesOnConnection  } = this.options.relayOptions;
    const edgesNullableOption = edgesNullableField !== null && edgesNullableField !== void 0 ? edgesNullableField : edgesNullable;
    const edgeListNullable = typeof edgesNullableOption === 'object' ? edgesNullableOption.list : !!edgesNullableOption;
    const edgeItemsNullable = typeof edgesNullableOption === 'object' && 'items' in edgesNullableOption ? edgesNullableOption.items : false;
    var _ref, _ref1, _con_edges_map;
    this.objectType(connectionRef, {
        ...(_this_options_relayOptions = this.options.relayOptions) === null || _this_options_relayOptions === void 0 ? void 0 : _this_options_relayOptions.defaultConnectionTypeOptions,
        ...connectionOptions,
        fields: (t)=>{
            var _this_options_relayOptions, _this_options_relayOptions_nodeFieldOptions;
            return {
                pageInfo: t.field({
                    nullable: false,
                    ...pageInfoFieldOptions,
                    type: this.pageInfoRef(),
                    resolve: (parent)=>parent.pageInfo
                }),
                edges: t.field({
                    nullable: edgesNullableField !== null && edgesNullableField !== void 0 ? edgesNullableField : edgesNullable,
                    ...edgesFieldOptions,
                    type: [
                        edgeRef
                    ],
                    resolve: (parent)=>parent.edges
                }),
                ...nodesOnConnection ? {
                    nodes: t.field({
                        ...typeof nodesOnConnection === 'object' ? nodesOnConnection : {},
                        type: [
                            type
                        ],
                        nullable: {
                            list: edgeListNullable,
                            items: (_ref1 = (_ref = edgeItemsNullable !== null && edgeItemsNullable !== void 0 ? edgeItemsNullable : nodeNullable) !== null && _ref !== void 0 ? _ref : (_this_options_relayOptions = this.options.relayOptions) === null || _this_options_relayOptions === void 0 ? void 0 : (_this_options_relayOptions_nodeFieldOptions = _this_options_relayOptions.nodeFieldOptions) === null || _this_options_relayOptions_nodeFieldOptions === void 0 ? void 0 : _this_options_relayOptions_nodeFieldOptions.nullable) !== null && _ref1 !== void 0 ? _ref1 : false
                        },
                        resolve: (con)=>{
                            var _con_edges;
                            return (_con_edges_map = (_con_edges = con.edges) === null || _con_edges === void 0 ? void 0 : _con_edges.map((edge)=>{
                                return edge === null || edge === void 0 ? void 0 : edge.node;
                            })) !== null && _con_edges_map !== void 0 ? _con_edges_map : [];
                        }
                    })
                } : {},
                ...connectionFields === null || connectionFields === void 0 ? void 0 : connectionFields(t)
            };
        }
    });
    if (!connectionRefs.has(this)) {
        connectionRefs.set(this, []);
    }
    connectionRefs.get(this).push(connectionRef);
    (_globalConnectionFieldsMap_get = globalConnectionFieldsMap.get(this)) === null || _globalConnectionFieldsMap_get === void 0 ? void 0 : _globalConnectionFieldsMap_get.forEach((fieldFn)=>void fieldFn(connectionRef));
    return connectionRef;
};
schemaBuilderProto.edgeObject = function edgeObject({ type , name: edgeName , nodeNullable: nodeFieldNullable , ...edgeOptions }) {
    var _this_options_relayOptions;
    (0, _core.verifyRef)(type);
    const { cursorType ='String' , cursorFieldOptions ={} , nodeFieldOptions: { nullable: nodeNullable = false , ...nodeFieldOptions } = {}  } = this.options.relayOptions;
    const edgeRef = this.objectRef(edgeName);
    const edgeFields = edgeOptions.fields;
    this.objectType(edgeRef, {
        ...(_this_options_relayOptions = this.options.relayOptions) === null || _this_options_relayOptions === void 0 ? void 0 : _this_options_relayOptions.defaultEdgeTypeOptions,
        ...edgeOptions,
        fields: (t)=>{
            return {
                node: t.field({
                    nullable: nodeFieldNullable !== null && nodeFieldNullable !== void 0 ? nodeFieldNullable : nodeNullable,
                    ...nodeFieldOptions,
                    type,
                    resolve: (parent)=>parent.node
                }),
                cursor: t.expose('cursor', {
                    nullable: false,
                    type: cursorType,
                    ...cursorFieldOptions
                }),
                ...edgeFields === null || edgeFields === void 0 ? void 0 : edgeFields(t)
            };
        }
    });
    return edgeRef;
};

//# sourceMappingURL=schema-builder.js.map