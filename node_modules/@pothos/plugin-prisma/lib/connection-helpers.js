"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    prismaModelKey: ()=>prismaModelKey,
    prismaConnectionHelpers: ()=>prismaConnectionHelpers
});
const _modelLoader = require("./model-loader");
const _cursors = require("./util/cursors");
const _datamodel = require("./util/datamodel");
const _getClient = require("./util/get-client");
const _relationMap = require("./util/relation-map");
const _selections = require("./util/selections");
const prismaModelKey = Symbol.for('Pothos.prismaModelKey');
function prismaConnectionHelpers(builder, refOrType, options) {
    const modelName = typeof refOrType === 'string' ? refOrType : refOrType.modelName;
    const ref = typeof refOrType === 'string' ? (0, _datamodel.getRefFromModel)(modelName, builder) : refOrType;
    const formatCursor = (0, _cursors.getCursorFormatter)(modelName, builder, options.cursor);
    const parseCursor = (0, _cursors.getCursorParser)(modelName, builder, options.cursor);
    const cursorSelection = _modelLoader.ModelLoader.getCursorSelection(ref, modelName, options.cursor, builder);
    const fieldMap = (0, _relationMap.getRelationMap)((0, _getClient.getDMMF)(builder)).get(modelName);
    function resolve(list, args, ctx) {
        var _ref;
        return (0, _cursors.wrapConnectionResult)(list, args, getQueryArgs(args, ctx).take, formatCursor, null, (_ref = options === null || options === void 0 ? void 0 : options.resolveNode) !== null && _ref !== void 0 ? _ref : (edge)=>edge);
    }
    function getQueryArgs(args, ctx) {
        return (0, _cursors.prismaCursorConnectionQuery)({
            args,
            ctx,
            maxSize: typeof options.maxSize === 'function' ? options.maxSize(args, ctx) : options.maxSize,
            defaultSize: typeof options.defaultSize === 'function' ? options.defaultSize(args, ctx) : options.defaultSize,
            parseCursor
        });
    }
    function getQuery(args, ctx, nestedSelection) {
        const nestedSelect = options.select ? {
            select: options.select((sel)=>nestedSelection(sel, [
                    'edges',
                    'node'
                ]))
        } : nestedSelection(true, [
            'edges',
            'node'
        ]);
        const selectState = (0, _selections.createState)(fieldMap, 'select');
        (0, _selections.mergeSelection)(selectState, {
            select: cursorSelection
        });
        if (typeof nestedSelect === 'object' && nestedSelect) {
            (0, _selections.mergeSelection)(selectState, nestedSelect);
        }
        return {
            ...getQueryArgs(args, ctx),
            ...(0, _selections.selectionToQuery)(selectState)
        };
    }
    var _options_select;
    return {
        ref: typeof refOrType === 'string' ? (0, _datamodel.getRefFromModel)(refOrType, builder) : refOrType,
        resolve,
        select: (_options_select = options.select) !== null && _options_select !== void 0 ? _options_select : {},
        getQuery
    };
}

//# sourceMappingURL=connection-helpers.js.map