import { SchemaTypes } from '@pothos/core';
import { PrismaObjectRef } from './object-ref';
import type { PrismaModelTypes, ShapeFromSelection } from './types';
export declare const prismaModelKey: unique symbol;
export declare function prismaConnectionHelpers<Types extends SchemaTypes, RefOrType extends PrismaObjectRef<PrismaModelTypes> | keyof Types['PrismaTypes'], Select extends Model['Select'] & {}, Model extends PrismaModelTypes = RefOrType extends PrismaObjectRef<infer T> ? T & PrismaModelTypes : Types['PrismaTypes'][RefOrType & keyof Types['PrismaTypes']] & PrismaModelTypes, Shape = RefOrType extends PrismaObjectRef<PrismaModelTypes, infer T> ? T : Model['Shape'], EdgeShape = Model['Include'] extends Select ? Shape : ShapeFromSelection<Model, {
    select: Select;
}>, NodeShape = EdgeShape>(builder: PothosSchemaTypes.SchemaBuilder<Types>, refOrType: RefOrType, options: {
    cursor: string & keyof Model['WhereUnique'];
    select?: (nestedSelection: <T extends {} | true>(selection?: T) => T) => Select;
    defaultSize?: number | ((args: PothosSchemaTypes.DefaultConnectionArguments, ctx: {}) => number);
    maxSize?: number | ((args: PothosSchemaTypes.DefaultConnectionArguments, ctx: {}) => number);
    resolveNode?: (edge: EdgeShape) => NodeShape;
}): {
    ref: PrismaObjectRef<Model, {}>;
    resolve: (list: (EdgeShape & {})[], args: PothosSchemaTypes.DefaultConnectionArguments, ctx: Types['Context']) => {
        edges: (Omit<EdgeShape, 'cursor' | 'node'> & {
            node: NodeShape;
            cursor: string;
        })[];
        pageInfo: {
            startCursor: string | null;
            endCursor: string | null;
            hasPreviousPage: boolean;
            hasNextPage: boolean;
        };
    };
    select: {};
    getQuery: (args: PothosSchemaTypes.DefaultConnectionArguments, ctx: Types['Context'], nestedSelection: <T extends true | {}>(selection?: T | undefined, path?: string[]) => T) => ({
        take: number;
        skip: number;
        cursor?: undefined;
    } | {
        cursor: Record<string, unknown>;
        take: number;
        skip: number;
    }) & (Model["Select"] extends Select ? {} : {
        select: Select;
    });
};
//# sourceMappingURL=connection-helpers.d.ts.map