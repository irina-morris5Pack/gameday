/* eslint-disable no-param-reassign */ /* eslint-disable no-continue */ import { getArgumentValues, getNamedType, isObjectType, Kind } from 'graphql';
import { setLoaderMappings } from './loader-map.js';
import { createState, mergeSelection, selectionCompatible, selectionToQuery } from './selections.js';
function addTypeSelectionsForField(type, context, info, state, selection, indirectPath) {
    if (selection.name.value.startsWith("__")) {
        return;
    }
    var _type_extensions;
    const { pothosPrismaInclude, pothosPrismaSelect, pothosPrismaIndirectInclude, pothosPrismaModel } = (_type_extensions = type.extensions) !== null && _type_extensions !== void 0 ? _type_extensions : {};
    if (pothosPrismaIndirectInclude) {
        resolveIndirectInclude(type, info, selection, pothosPrismaIndirectInclude.path, indirectPath, (resolvedType, field, path) => {
            addTypeSelectionsForField(resolvedType, context, info, state, field, path);
        });
    }
    if (!isObjectType(type)) {
        return;
    }
    if (pothosPrismaModel && !pothosPrismaSelect) {
        state.mode = "include";
    }
    if (pothosPrismaInclude || pothosPrismaSelect) {
        mergeSelection(state, {
            select: pothosPrismaSelect ? {
                ...pothosPrismaSelect
            } : undefined,
            include: pothosPrismaInclude ? {
                ...pothosPrismaInclude
            } : undefined
        });
    }
    if (selection.selectionSet) {
        addNestedSelections(type, context, info, state, selection.selectionSet, indirectPath);
    }
}
function resolveIndirectInclude(type, info, selection, includePath, path, resolve) {
    if (includePath.length === 0) {
        resolve(type, selection, path);
        return;
    }
    const [include, ...rest] = includePath;
    if (!selection.selectionSet || !include) {
        return;
    }
    for (const sel of selection.selectionSet.selections) {
        switch (sel.kind) {
            case Kind.FIELD:
                if (sel.name.value === include.name && isObjectType(type)) {
                    var _sel_alias;
                    const returnType = getNamedType(type.getFields()[sel.name.value].type);
                    var _sel_alias_value;
                    resolveIndirectInclude(returnType, info, sel, rest, [
                        ...path,
                        (_sel_alias_value = (_sel_alias = sel.alias) === null || _sel_alias === void 0 ? void 0 : _sel_alias.value) !== null && _sel_alias_value !== void 0 ? _sel_alias_value : sel.name.value
                    ], resolve);
                }
                continue;
            case Kind.FRAGMENT_SPREAD:
                if (info.fragments[sel.name.value].typeCondition.name.value === include.type) {
                    resolveIndirectInclude(info.schema.getType(include.type), info, info.fragments[sel.name.value], includePath, path, resolve);
                }
                continue;
            case Kind.INLINE_FRAGMENT:
                if (!sel.typeCondition || sel.typeCondition.name.value === include.type) {
                    resolveIndirectInclude(sel.typeCondition ? info.schema.getType(sel.typeCondition.name.value) : type, info, sel, includePath, path, resolve);
                }
                continue;
            default:
                throw new Error(`Unsupported selection kind ${selection.kind}`);
        }
    }
}
function addNestedSelections(type, context, info, state, selections, indirectPath) {
    for (const selection of selections.selections) {
        switch (selection.kind) {
            case Kind.FIELD:
                addFieldSelection(type, context, info, state, selection, indirectPath);
                continue;
            case Kind.FRAGMENT_SPREAD:
                if (info.fragments[selection.name.value].typeCondition.name.value !== type.name) {
                    continue;
                }
                addNestedSelections(type, context, info, state, info.fragments[selection.name.value].selectionSet, indirectPath);
                continue;
            case Kind.INLINE_FRAGMENT:
                if (selection.typeCondition && selection.typeCondition.name.value !== type.name) {
                    continue;
                }
                addNestedSelections(type, context, info, state, selection.selectionSet, indirectPath);
                continue;
            default:
                throw new Error(`Unsupported selection kind ${selection.kind}`);
        }
    }
}
function addFieldSelection(type, context, info, state, selection, indirectPath) {
    var _field_extensions;
    if (selection.name.value.startsWith("__")) {
        return;
    }
    const field = type.getFields()[selection.name.value];
    if (!field) {
        throw new Error(`Unknown field ${selection.name.value} on ${type.name}`);
    }
    const fieldSelect = (_field_extensions = field.extensions) === null || _field_extensions === void 0 ? void 0 : _field_extensions.pothosPrismaSelect;
    let fieldSelectionMap;
    let mappings = {};
    if (typeof fieldSelect === "function") {
        const args = getArgumentValues(field, selection, info.variableValues);
        fieldSelectionMap = fieldSelect(args, context, (rawQuery, indirectInclude) => {
            const returnType = getNamedType(field.type);
            const query = typeof rawQuery === "function" ? rawQuery(args, context) : rawQuery;
            const normalizedIndirectInclude = Array.isArray(indirectInclude) ? normalizeInclude(indirectInclude, getIndirectType(returnType, info)) : indirectInclude;
            const fieldState = createStateForType(getIndirectType(normalizedIndirectInclude ? info.schema.getType(normalizedIndirectInclude.getType()) : returnType, info), info, state);
            if (typeof query === "object" && Object.keys(query).length > 0) {
                mergeSelection(fieldState, {
                    select: {},
                    ...query
                });
            }
            if (normalizedIndirectInclude && normalizedIndirectInclude.path.length > 0) {
                var _ref, _returnType_extensions;
                var _path;
                resolveIndirectInclude(returnType, info, selection, [
                    ...(_path = (_ref = (_returnType_extensions = returnType.extensions) === null || _returnType_extensions === void 0 ? void 0 : _returnType_extensions.pothosPrismaIndirectInclude) === null || _ref === void 0 ? void 0 : _ref.path) !== null && _path !== void 0 ? _path : [],
                    ...normalizedIndirectInclude.path
                ], [], (resolvedType, resolvedField, path) => {
                    addTypeSelectionsForField(resolvedType, context, info, fieldState, resolvedField, path);
                });
            }
            addTypeSelectionsForField(returnType, context, info, fieldState, selection, []);
            // eslint-disable-next-line prefer-destructuring
            mappings = fieldState.mappings;
            return selectionToQuery(fieldState);
        }, (path) => {
            const returnType = getNamedType(field.type);
            let node = null;
            resolveIndirectInclude(returnType, info, selection, path.map((name) => ({
                name
            })), [], (_, resolvedField) => {
                node = resolvedField;
            });
            return node;
        });
    }
    else {
        fieldSelectionMap = {
            select: fieldSelect
        };
    }
    if (fieldSelect && selectionCompatible(state, fieldSelectionMap, true)) {
        var _selection_alias;
        mergeSelection(state, fieldSelectionMap);
        var _selection_alias_value;
        state.mappings[(_selection_alias_value = (_selection_alias = selection.alias) === null || _selection_alias === void 0 ? void 0 : _selection_alias.value) !== null && _selection_alias_value !== void 0 ? _selection_alias_value : selection.name.value] = {
            field: selection.name.value,
            type: type.name,
            mappings,
            indirectPath
        };
    }
}
export function queryFromInfo({ context, info, typeName, select, path = [] }) {
    const returnType = getNamedType(info.returnType);
    const type = typeName ? info.schema.getTypeMap()[typeName] : returnType;
    const state = createStateForType(type, info);
    if (select) {
        mergeSelection(state, {
            select
        });
    }
    if (path.length > 0) {
        var _returnType_extensions;
        const { pothosPrismaIndirectInclude } = (_returnType_extensions = returnType.extensions) !== null && _returnType_extensions !== void 0 ? _returnType_extensions : {};
        var _pothosPrismaIndirectInclude_path;
        resolveIndirectInclude(returnType, info, info.fieldNodes[0], (_pothosPrismaIndirectInclude_path = pothosPrismaIndirectInclude === null || pothosPrismaIndirectInclude === void 0 ? void 0 : pothosPrismaIndirectInclude.path) !== null && _pothosPrismaIndirectInclude_path !== void 0 ? _pothosPrismaIndirectInclude_path : [], [], (indirectType, indirectField, subPath) => {
            resolveIndirectInclude(indirectType, info, indirectField, path.map((n) => typeof n === "string" ? {
                name: n
            } : n), subPath, (resolvedType, resolvedField, nested) => {
                addTypeSelectionsForField(resolvedType, context, info, state, resolvedField, nested);
            });
        });
    }
    else {
        addTypeSelectionsForField(type, context, info, state, info.fieldNodes[0], []);
    }
    setLoaderMappings(context, info, state.mappings);
    return selectionToQuery(state);
}
export function selectionStateFromInfo(context, info, typeName) {
    const type = typeName ? info.schema.getTypeMap()[typeName] : info.parentType;
    const state = createStateForType(type, info);
    if (!isObjectType(type)) {
        throw new Error("Prisma plugin can only resolve includes for object types");
    }
    addFieldSelection(type, context, info, state, info.fieldNodes[0], []);
    return state;
}
function createStateForType(type, info, parent) {
    var _targetType_extensions, _targetType_extensions1;
    const targetType = getIndirectType(type, info);
    const fieldMap = (_targetType_extensions = targetType.extensions) === null || _targetType_extensions === void 0 ? void 0 : _targetType_extensions.pothosPrismaFieldMap;
    return createState(fieldMap, ((_targetType_extensions1 = targetType.extensions) === null || _targetType_extensions1 === void 0 ? void 0 : _targetType_extensions1.pothosPrismaSelect) ? "select" : "include", parent);
}
export function getIndirectType(type, info) {
    var _targetType_extensions;
    let targetType = type;
    while ((_targetType_extensions = targetType.extensions) === null || _targetType_extensions === void 0 ? void 0 : _targetType_extensions.pothosPrismaIndirectInclude) {
        var _targetType_extensions1;
        targetType = info.schema.getType(((_targetType_extensions1 = targetType.extensions) === null || _targetType_extensions1 === void 0 ? void 0 : _targetType_extensions1.pothosPrismaIndirectInclude).getType());
    }
    return targetType;
}
function normalizeInclude(path, type) {
    let currentType = type;
    const normalized = [];
    if (!isObjectType(currentType)) {
        throw new Error(`Expected ${currentType} to be an Object type`);
    }
    for (const fieldName of path) {
        const field = currentType.getFields()[fieldName];
        if (!field) {
            throw new Error(`Expected ${currentType} to have a field ${fieldName}`);
        }
        currentType = getNamedType(field.type);
        if (!isObjectType(currentType)) {
            throw new Error(`Expected ${currentType} to be an Object type`);
        }
        normalized.push({
            name: fieldName,
            type: currentType.name
        });
    }
    return {
        getType: () => normalized.length > 0 ? normalized[normalized.length - 1].type : type.name,
        path: normalized
    };
}
//# sourceMappingURL=map-query.js.map
