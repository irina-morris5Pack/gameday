import { ModelLoader } from './model-loader.js';
import { getCursorFormatter, getCursorParser, prismaCursorConnectionQuery, wrapConnectionResult } from './util/cursors.js';
import { getRefFromModel } from './util/datamodel.js';
import { getDMMF } from './util/get-client.js';
import { getRelationMap } from './util/relation-map.js';
import { createState, mergeSelection, selectionToQuery } from './util/selections.js';
export const prismaModelKey = Symbol.for("Pothos.prismaModelKey");
export function prismaConnectionHelpers(builder, refOrType, options) {
    const modelName = typeof refOrType === "string" ? refOrType : refOrType.modelName;
    const ref = typeof refOrType === "string" ? getRefFromModel(modelName, builder) : refOrType;
    const formatCursor = getCursorFormatter(modelName, builder, options.cursor);
    const parseCursor = getCursorParser(modelName, builder, options.cursor);
    const cursorSelection = ModelLoader.getCursorSelection(ref, modelName, options.cursor, builder);
    const fieldMap = getRelationMap(getDMMF(builder)).get(modelName);
    function resolve(list, args, ctx) {
        var _ref;
        return wrapConnectionResult(list, args, getQueryArgs(args, ctx).take, formatCursor, null, (_ref = options === null || options === void 0 ? void 0 : options.resolveNode) !== null && _ref !== void 0 ? _ref : (edge) => edge);
    }
    function getQueryArgs(args, ctx) {
        return prismaCursorConnectionQuery({
            args,
            ctx,
            maxSize: typeof options.maxSize === "function" ? options.maxSize(args, ctx) : options.maxSize,
            defaultSize: typeof options.defaultSize === "function" ? options.defaultSize(args, ctx) : options.defaultSize,
            parseCursor
        });
    }
    function getQuery(args, ctx, nestedSelection) {
        const nestedSelect = options.select ? {
            select: options.select((sel) => nestedSelection(sel, [
                "edges",
                "node"
            ]))
        } : nestedSelection(true, [
            "edges",
            "node"
        ]);
        const selectState = createState(fieldMap, "select");
        mergeSelection(selectState, {
            select: cursorSelection
        });
        if (typeof nestedSelect === "object" && nestedSelect) {
            mergeSelection(selectState, nestedSelect);
        }
        return {
            ...getQueryArgs(args, ctx),
            ...selectionToQuery(selectState)
        };
    }
    var _options_select;
    return {
        ref: typeof refOrType === "string" ? getRefFromModel(refOrType, builder) : refOrType,
        resolve,
        select: (_options_select = options.select) !== null && _options_select !== void 0 ? _options_select : {},
        getQuery
    };
}
//# sourceMappingURL=connection-helpers.js.map
